package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"strings"
)

var structName = "AutoGenerated"
var structDefinitions = make(map[string]string) // 存储结构体定义
var sliceDefinitions string                     // 存储结构体定义

func Json2Struct(jsonData, name string) (string, error) {
	if name != "" {
		structName = name
	}
	// 解码 JSON 数据到通用结构
	var data any
	if err := json.Unmarshal([]byte(jsonData), &data); err != nil {
		fmt.Println("Error decoding JSON:", err)
		return "", err
	}
	// 判断数据类型并生成结构体
	switch parsed := data.(type) {
	case []any:
		parsedSlice(parsed)
	case map[string]any:
		// 处理单个对象
		structDefinitions[structName] = generateStruct(parsed)
	default:
		fmt.Println("Unsupported JSON format")
		return "", errors.New("Unsupported JSON format")
	}

	// 生成顶级结构体
	builder := strings.Builder{}
	// 打印所有结构体
	for name, def := range structDefinitions {
		builder.WriteString(fmt.Sprintf("type %s struct {\n%s\n}\n\n", name, def))
		//fmt.Printf("type %s struct {\n%s\n}\n\n", name, def)
	}
	if sliceDefinitions != "" {
		builder.WriteString(fmt.Sprintf("type %s %s\n", structName, sliceDefinitions))
	}
	return builder.String(), nil
}

func parsedSlice(parsed []any) {
	// 处理数组类型，提取第一个元素推断结构体
	if len(parsed) > 0 {
		switch item := parsed[0].(type) {
		case map[string]any:
			structDefinitions[structName] = generateStruct(item)
		case []any:
			parsedSlice(item)
		case any:
			typ := goType(structName, item)
			sliceDefinitions = fmt.Sprintf("[]%s", typ)
		}
	}
}

// 将字段名转换为大写驼峰命名
func toCamelCase(input string) string {
	parts := strings.Split(input, "_")
	for i := range parts {
		parts[i] = strings.Title(parts[i])
	}
	return strings.Join(parts, "")
}

// 根据 JSON 值推断 Go 类型，并生成嵌套结构体
func goType(fieldName string, value any) string {
	switch v := value.(type) {
	case string:
		return "string"
	case float64:
		// JSON 数字默认解析为 float64，需判断是否为整数
		if float64(int64(v)) == v {
			return "int64"
		}
		return "float64"
	case bool:
		return "bool"
	case []any:
		if len(v) > 0 {
			return "[]" + goType(fieldName, v[0]) // 推断数组元素类型
		}
		return "[]interface{}"
	case map[string]any:
		// 为嵌套结构体生成一个新类型名
		nestedStructName := toCamelCase(fieldName) + "Struct"
		nestedStruct := generateStruct(v)
		structDefinitions[nestedStructName] = nestedStruct
		return nestedStructName
	default:
		return "interface{}"
	}
}

// 生成结构体定义
func generateStruct(data map[string]any) string {
	var fields []string
	for key, value := range data {
		fieldName := toCamelCase(key)
		fieldType := goType(fieldName, value)
		fields = append(fields, fmt.Sprintf("\t%s %s `json:\"%s\"`", fieldName, fieldType, key))
	}
	return strings.Join(fields, "\n")
}
